import sys
import os
import time
import logging
import json
import requests
import openai
import sqliteHandler
import chardet
import re

MODEL = "gpt-3.5-turbo"
#MODEL = "gpt-4"


# openAI SYSTEM
system_text = """return up to 2 keywords (only nouns) separated by spaces for this sentence:"""

# openAI user text, the rest wll be concatenated based on the task's request
user_text = ""


def chat_completion(system_text, user_text):
    """
    This function takes two arguments, 'system_text' and 'user_text', and generates a response using the OpenAI ChatCompletion API.

    Args:
    system_text (str): A string containing the system message to set the context for the conversation.
    user_text (str): A string containing the user message to which the function will generate a response.

    Returns:
    str: A message generated by the GPT-3.5-turbo model based on the input messages.

    Example usage:
    >>> system_text = "You are an AI language model."
    >>> user_text = "How does GPT-3.5-turbo work?"
    >>> response = chat_completion(system_text, user_text)
    >>> print(response)
    "GPT-3.5-turbo is a cutting-edge AI model that generates human-like text based on context and input. It works by predicting the next word in a sequence, using deep learning techniques and a vast training dataset."
    """
    response = openai.ChatCompletion.create(
        model=MODEL,
        messages=[
            {"role": "system", "content": system_text},
            {"role": "user", "content": user_text},
        ],
    )
    message = response["choices"][0]["message"]["content"]
    return message

def clean_string(input_string):
    # Remove all non-word characters (everything except numbers and letters)
    input_string = re.sub(r'\W', ' ', input_string)

    # Replace all runs of whitespace with a single space
    input_string = re.sub(r'\s+', ' ', input_string)

    # Remove leading and trailing whitespace
    input_string = input_string.strip()

    return input_string


if len(sys.argv) > 1:
    DEBUG_MODE = sys.argv[1]
else:
    # DEBUG_MODE = "debug", "info", anything else for off
    DEBUG_MODE = "off"
if DEBUG_MODE == "debug":
    logging.basicConfig(
        level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s"
    )
elif DEBUG_MODE == "info":
    logging.basicConfig(
        level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
    )
else:
    logging.disable(sys.maxsize)

TASKNAME = os.path.splitext(os.path.basename(__file__))[0]
KEY = os.environ.get("AIDEVS")
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
URL_AI_DEVS = os.environ.get("URL_AI_DEVS")

if not KEY:
    raise ValueError("API KEY cannot be empty, setup environment variable AIDEVS")
if not OPENAI_API_KEY:
    raise ValueError(
        "openAI API KEY cannot be empty, setup environment variable OPENAI_API_KEY"
    )
if not URL_AI_DEVS:
    raise ValueError(
        "URL for AI_devs cannot be empty, setup environment variable URL_AI_DEVS"
    )


LOAD = False
DATABASE = os.path.dirname(os.path.abspath(__file__)) + "/brain01.db"
print (DATABASE)
handler = sqliteHandler.SQLiteHandler(DATABASE)

if LOAD:
    rawdata = open('quotes.json', 'rb').read()
    result = chardet.detect(rawdata)
    encoding = result['encoding']
    print (f"Encoding: {encoding}")

    with open('quotes.json', 'r', encoding=encoding) as f:
        data = json.load(f)

    for row in data:
        if row['quoteAuthor'] != '':
            handler.insert_data(handler.db_table_brain, {"body" : f"{row['quoteAuthor']} said: {row['quoteText']}"})

#handler.print_data()
handler.print_select("SELECT count (*) FROM brain")
question = "what Buddha said about happines?"
question_keys = ""

openai.api_key = OPENAI_API_KEY


# response = requests.post(URL_AI_DEVS + TOKEN + TASKNAME, json=data)
# json_response = response.json()
# logging.info("Received json: %s", json_response)

# token = json_response.get("token")
# response = requests.get(URL_AI_DEVS + TASK + token)
# json_response = response.json()
# logging.info("Received json: %s", json_response)

#blog = json_response.get("blog")
#user_text += json.dumps(blog)
logging.info("Question: %s question")
start_time = time.time()
question_keys = chat_completion(system_text, question)
end_time = time.time()
duration = end_time - start_time
logging.info("Done after %s seconds", "{:.0f}".format(duration))
question_keys = clean_string(question_keys)
logging.info("key words to be found: %s", question_keys)
select = f"SELECT * FROM brain WHERE body MATCH(\'{question_keys}\')"
handler.print_select(select)
handler.close_connection()

#sys.exit(1)
# response = requests.post(URL_AI_DEVS + ANSWER + token, json=data)
# json_response = response.json()
# print(json_response)

